/* 
Boolean : true, false, NULL. It stores one byte.

Char : It stores limited length string.
VarChar : It stores fixed length string.
Text : It stores string without limiting

There is no performance differentiation between string types.

Numeric : It stores numbers with a lot of digits. It can be used for storign numbers that requre exactness such monetary amounts or quantities => column_name NUMERIC(percision, scale)
precision is the total number of digits, scale is the number of digits in the fraction part. price NUMERIC(7,2) total is 7, after fraction is 2.

NUMERIC and DECIMAL are the same they can be used interchangeably.
Special values are : Infinity, -Infinity, NaN
 

 Double precision and float are the same. They store approximate values.

 Integer : It stores the whole numbers. It has 3 types. SMALLINT, INTEGER, BIGINT which are 2 bytes, 4 bytes and 8 bytes respectively. There is no unsigned integer type.


 DATE : It stores date data. It is 4 bytes. Its lowest and highest data are 4713 BC and 5874897 AD respectively. For default value we can use CURRENT_DATE or NOW();

SELECT NOW()::date returns only date part.

TO_CHAR(CURRENT_DATE, "dd/mm/yyyy") returns the date as a string depending on the given format.

now() - created_at as diff => which returns number of days between now and created day.

AGE(date) function calculates the age.

The statements below extract year, month or date.

EXTRACT (YEAR FROM birth_date) AS YEAR,
EXTRACT (MONTH FROM birth_date) AS MONTH,
EXTRACT (DAY FROM birth_date) AS DAY

There are time, timestamp and interval types.




UUID stores a 128-bit quantity generated by an algorithm that makes it unique in the known universe using the same algorithm.
gen_random_uuid() function returns a uuid. It can be used as a primary key.

Array is a collection of elements that have the same data type. It can be one-dimensional, multi-dimensional or nested. Every data type has its own companion array type. When we define a user-defined type postgresql create array type.
column_name integer[]

To append an element we can use ARRAY_APPEND

UPDATE staff_data SET st_email = ARRAY_APPEND(st_email, "tim@staff.com") WHERE st_id = 2;

To search any data in the array we can use ANY function

SELECT name, phones FROM contacts WHERE '(408)-589-5555' = ANY (phones);

To expand the array we can use unnest. It flatten the array.

SELECT name,unnest(phones) FROM contacts;


hstore stores key-value pairs in a single value. The keys and values are text strings only. To enable it 

CREATE EXTENSION hstore;

*/

CREATE TABLE books (
	id serial primary key,
	title VARCHAR (255),
	attr hstore
);

INSERT INTO books (title, attr) 
VALUES 
  (
    'PostgreSQL Tutorial', '"paperback" => "243",
     "publisher" => "postgresqltutorial.com",
     "language"  => "English",
     "ISBN-13"   => "978-1449370000",
     "weight"    => "11.2 ounces"'
  );


SELECT attr -> 'ISBN-13' AS isbn FROM books;

SELECT title, attr -> 'weight' AS weight FROM books WHERE attr -> 'ISBN-13' = '978-1449370000';

/* Adding new value existing key value pair */
UPDATE books SET attr = attr || '"freeshipping"=>"yes"' :: hstore;
/* Delete existing pair */
UPDATE books SET attr = delete(attr, 'freeshipping');
/* Convert hstore into json */
SELECT title, hstore_to_json (attr) json FROM books;


/* JSON and JSONB

JSON stores an exact copy of the JSON text.
JSONB stores the JSON data in binary format.


 */

 CREATE TABLE products(
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    properties JSONB
);

INSERT INTO products(name, properties)
VALUES('Ink Fusion T-Shirt','{"color": "white", "size": ["S","M","L","XL"]}')
RETURNING *;

/* We can extract a value from the json */
SELECT id, name, properties -> 'color' color FROM products;

/* ENUM : It allows us to define a list of possible values for a column. it is case sensitive */
CREATE TYPE enum_name AS ENUM('value1', 'value2', 'value3', ...);

/* We can add a new value into the enum */
ALTER TYPE enum_name ADD VALUE 'new_value' BEFORE | AFTER 'existing_enum_value';
/* Retrieve all values for an enum */
SELECT enum_range(null::priority);

/* NOTE : We cant remove a value from enum */

/* BYTEA stores binary array. Its maximum size is 1GB but storing a large amount of binary data in a BYTEA is not efficient. */
CREATE TABLE binary_data(
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    data BYTEA
);

INSERT INTO binary_data(data) 
VALUES ('\x012345');

/* COMPOSITE type consists of one or more value. */
CREATE TYPE address_type AS(
   street text, 
   city text,
   state text, 
   zip_code integer,
   country text
);

CREATE TABLE contacts(
    id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    address address_type
);

/* We can use ROW function to add a value into a composite type */
INSERT INTO contacts (name, address)
VALUES (
    'John Smith',
    ROW('123 St', 'Houston', 'TX', 77001, 'USA')
);

/* Update a composite type */
UPDATE contacts
SET
  address.country= 'USA'
WHERE
  id = 2
RETURNING *;